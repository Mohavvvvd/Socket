package Socket;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.net.ssl.*;
import java.io.*;
import java.net.*;
import java.security.KeyStore;
import java.time.LocalDateTime;
import java.util.Base64;
import java.util.UUID;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Serveur TCP Ultra-Sécurisé
 * Protections contre :
 * - Man-in-the-Middle (MITM) : TLS 1.3
 * - Replay Attack : Nonce + Timestamp + Cache
 * - Altération : HMAC-SHA256
 * - DoS : Thread Pool + Limites de connexions + Timeouts
 * - Slow clients : Read timeout + Max line length
 */
public class SecureServer {
    
    // Configuration Sécurité
    private static final String SECRET_KEY = "VotreCleSuperSecrete2025!";
    private static final int PORT = 6443;
    private static final int READ_TIMEOUT_MS = 8000;
    private static final int MAX_LINE_LENGTH = 4096;
    private static final long REPLAY_WINDOW_MS = 15000; // 15 secondes
    private static final int MAX_CONNECTIONS = 64;
    
    // Gestion des connexions
    private static final ExecutorService threadPool = new ThreadPoolExecutor(
        8, 32, 60, TimeUnit.SECONDS, 
        new LinkedBlockingQueue<>(128),
        new ThreadPoolExecutor.CallerRunsPolicy()
    );
    private static final AtomicInteger activeConnections = new AtomicInteger(0);
    
    // Cache anti-replay : stocke les nonces déjà vus
    private static final ConcurrentMap<String, Long> nonceCache = new ConcurrentHashMap<>();
    
    public static void main(String[] args) {
        try {
            // Démarrer le serveur TLS
            SSLServerSocket serverSocket = createTLSServerSocket(PORT);
            System.out.println("=================================================");
            System.out.println("[SECURE SERVER] Démarré sur le port " + PORT);
            System.out.println("[TLS] Version: TLSv1.3");
            System.out.println("[PROTECTION] Anti-Replay, HMAC, Rate Limiting");
            System.out.println("=================================================\n");
            
            // Nettoyer le cache périodiquement
            startCacheCleanupTask();
            
            // Accepter les connexions
            while (true) {
                try {
                    SSLSocket clientSocket = (SSLSocket) serverSocket.accept();
                    
                    // Vérifier la limite de connexions
                    if (activeConnections.get() >= MAX_CONNECTIONS) {
                        log("REFUSÉ - Trop de connexions actives (" + activeConnections.get() + ")");
                        clientSocket.close();
                        continue;
                    }
                    
                    activeConnections.incrementAndGet();
                    threadPool.submit(() -> handleClient(clientSocket));
                    
                } catch (IOException e) {
                    log("Erreur acceptation: " + e.getMessage());
                }
            }
        } catch (Exception e) {
            System.err.println("[FATAL] Impossible de démarrer le serveur: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Crée un ServerSocket TLS sécurisé
     */
    private static SSLServerSocket createTLSServerSocket(int port) throws Exception {
        // Charger le keystore (à créer avec keytool)
        char[] keystorePassword = "changeit".toCharArray();
        KeyStore keystore = KeyStore.getInstance("JKS");
        
        // Pour ce code, on suppose que serverkeystore.jks existe
        // Créer avec: keytool -genkeypair -alias serverkey -keyalg RSA -keysize 2048 
        //             -keystore serverkeystore.jks -validity 365 -storepass changeit
        try (FileInputStream fis = new FileInputStream("serverkeystore.jks")) {
            keystore.load(fis, keystorePassword);
        }
        
        // Initialiser le KeyManager
        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
        kmf.init(keystore, keystorePassword);
        
        // Créer le contexte SSL avec TLS 1.3
        SSLContext sslContext = SSLContext.getInstance("TLSv1.3");
        sslContext.init(kmf.getKeyManagers(), null, null);
        
        // Créer le ServerSocket TLS
        SSLServerSocketFactory factory = sslContext.getServerSocketFactory();
        SSLServerSocket serverSocket = (SSLServerSocket) factory.createServerSocket(port);
        
        // Forcer TLS 1.3 uniquement
        serverSocket.setEnabledProtocols(new String[]{"TLSv1.3"});
        
        return serverSocket;
    }
    
    /**
     * Traite une connexion client
     */
    private static void handleClient(SSLSocket clientSocket) {
        String clientInfo = clientSocket.getRemoteSocketAddress().toString();
        
        try {
            clientSocket.setSoTimeout(READ_TIMEOUT_MS);
            
            BufferedReader in = new BufferedReader(
                new InputStreamReader(clientSocket.getInputStream(), "UTF-8")
            );
            BufferedWriter out = new BufferedWriter(
                new OutputStreamWriter(clientSocket.getOutputStream(), "UTF-8")
            );
            
            log("CONNECTÉ: " + clientInfo);
            
            // Lire et traiter les messages
            String line;
            while ((line = readBoundedLine(in)) != null) {
                String response = processSecureMessage(line, clientInfo);
                out.write(response + "\r\n");
                out.flush();
            }
            
        } catch (SocketTimeoutException e) {
            log("TIMEOUT: " + clientInfo);
        } catch (IOException e) {
            log("ERREUR I/O: " + clientInfo + " - " + e.getMessage());
        } finally {
            try {
                clientSocket.close();
            } catch (IOException ignored) {}
            activeConnections.decrementAndGet();
            log("DÉCONNECTÉ: " + clientInfo + " (Actifs: " + activeConnections.get() + ")");
        }
    }
    
    /**
     * Traite un message sécurisé avec vérifications anti-attaque
     * Format attendu: NONCE|TIMESTAMP|MESSAGE|HMAC
     */
    private static String processSecureMessage(String line, String clientInfo) {
        try {
            // Parser le message
            String[] parts = line.split("\\|", 4);
            if (parts.length != 4) {
                log("FORMAT INVALIDE: " + clientInfo);
                return "ERR:FORMAT_INVALIDE";
            }
            
            String nonce = parts[0];
            String timestampStr = parts[1];
            String message = parts[2];
            String receivedHmac = parts[3];
            
            // Vérifier le timestamp (anti-replay temporel)
            long timestamp;
            try {
                timestamp = Long.parseLong(timestampStr);
            } catch (NumberFormatException e) {
                log("TIMESTAMP INVALIDE: " + clientInfo);
                return "ERR:TIMESTAMP_INVALIDE";
            }
            
            long now = System.currentTimeMillis();
            long timeDiff = Math.abs(now - timestamp);
            
            if (timeDiff > REPLAY_WINDOW_MS) {
                log("REPLAY DÉTECTÉ (temps): " + clientInfo + " - Diff: " + timeDiff + "ms");
                return "ERR:MESSAGE_EXPIRE";
            }
            
            // Vérifier le nonce (anti-replay par unicité)
            if (nonceCache.putIfAbsent(nonce, now) != null) {
                log("REPLAY DÉTECTÉ (nonce): " + clientInfo + " - Nonce: " + nonce);
                return "ERR:REPLAY_ATTACK";
            }
            
            // Vérifier l'intégrité avec HMAC
            String data = nonce + "|" + timestamp + "|" + message;
            String expectedHmac = calculateHMAC(data, SECRET_KEY);
            
            if (!expectedHmac.equals(receivedHmac)) {
                log("HMAC INVALIDE: " + clientInfo + " - Altération détectée!");
                return "ERR:INTEGRITE_COMPROMISE";
            }
            
            // Message valide - Traiter
            log("MESSAGE VALIDE: " + clientInfo + " - " + preview(message));
            return "OK:MESSAGE_ACCEPTE:" + message;
            
        } catch (Exception e) {
            log("ERREUR TRAITEMENT: " + clientInfo + " - " + e.getMessage());
            return "ERR:ERREUR_SERVEUR";
        }
    }
    
    /**
     * Calcule le HMAC-SHA256 d'un message
     */
    private static String calculateHMAC(String data, String secret) throws Exception {
        Mac mac = Mac.getInstance("HmacSHA256");
        SecretKeySpec keySpec = new SecretKeySpec(secret.getBytes("UTF-8"), "HmacSHA256");
        mac.init(keySpec);
        byte[] hmacBytes = mac.doFinal(data.getBytes("UTF-8"));
        return Base64.getEncoder().encodeToString(hmacBytes);
    }
    
    /**
     * Lit une ligne avec limitation de taille (anti-DoS)
     */
    private static String readBoundedLine(BufferedReader in) throws IOException {
        StringBuilder sb = new StringBuilder();
        int ch;
        
        while ((ch = in.read()) != -1) {
            if (ch == '\n') {
                break;
            }
            if (ch != '\r') {
                sb.append((char) ch);
            }
            if (sb.length() > MAX_LINE_LENGTH) {
                throw new IOException("Ligne trop longue (> " + MAX_LINE_LENGTH + ")");
            }
        }
        
        return (sb.length() == 0 && ch == -1) ? null : sb.toString();
    }
    
    /**
     * Nettoie périodiquement le cache des nonces expirés
     */
    private static void startCacheCleanupTask() {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        scheduler.scheduleAtFixedRate(() -> {
            long now = System.currentTimeMillis();
            int removed = 0;
            
            for (var entry : nonceCache.entrySet()) {
                if (now - entry.getValue() > REPLAY_WINDOW_MS) {
                    nonceCache.remove(entry.getKey());
                    removed++;
                }
            }
            
            if (removed > 0) {
                log("Cache nettoyé: " + removed + " entrées supprimées");
            }
        }, 10, 10, TimeUnit.SECONDS);
    }
    
    /**
     * Prévisualisation d'un message (tronqué si trop long)
     */
    private static String preview(String s) {
        return s.length() > 60 ? s.substring(0, 60) + "..." : s;
    }
    
    /**
     * Journalisation avec timestamp
     */
    private static void log(String message) {
        System.out.println("[" + LocalDateTime.now() + "] " + message);
    }
}


/**
 * Client sécurisé correspondant
 */
class SecureClient {
    private static final String SECRET_KEY = "Serveur Plus securise que Studrz";
    private static final String SERVER_HOST = "localhost";
    private static final int SERVER_PORT = 6443;
    
    public static void main(String[] args) {
        try {
            // Créer contexte SSL (en production, vérifier le certificat!)
            SSLContext sslContext = createTrustAllSSLContext();
            SSLSocketFactory factory = sslContext.getSocketFactory();
            
            try (SSLSocket socket = (SSLSocket) factory.createSocket(SERVER_HOST, SERVER_PORT);
                 BufferedReader console = new BufferedReader(new InputStreamReader(System.in));
                 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream(), "UTF-8"));
                 BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), "UTF-8"))) {
                
                System.out.println("=== Client Sécurisé connecté à " + SERVER_HOST + ":" + SERVER_PORT + " ===");
                System.out.println("Tapez vos messages (exit pour quitter)\n");
                
                String message;
                while (true) {
                    System.out.print("> ");
                    message = console.readLine();
                    
                    if (message == null || "exit".equalsIgnoreCase(message.trim())) {
                        break;
                    }
                    
                    // Créer un message sécurisé
                    String secureMessage = createSecureMessage(message);
                    out.write(secureMessage + "\r\n");
                    out.flush();
                    
                    // Lire la réponse
                    String response = in.readLine();
                    System.out.println("Serveur: " + response + "\n");
                }
            }
            
        } catch (Exception e) {
            System.err.println("Erreur: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Crée un message sécurisé au format: NONCE|TIMESTAMP|MESSAGE|HMAC
     */
    private static String createSecureMessage(String message) throws Exception {
        String nonce = UUID.randomUUID().toString();
        long timestamp = System.currentTimeMillis();
        String data = nonce + "|" + timestamp + "|" + message;
        String hmac = calculateHMAC(data, SECRET_KEY);
        
        return data + "|" + hmac;
    }
    
    private static String calculateHMAC(String data, String secret) throws Exception {
        Mac mac = Mac.getInstance("HmacSHA256");
        SecretKeySpec keySpec = new SecretKeySpec(secret.getBytes("UTF-8"), "HmacSHA256");
        mac.init(keySpec);
        byte[] hmacBytes = mac.doFinal(data.getBytes("UTF-8"));
        return Base64.getEncoder().encodeToString(hmacBytes);
    }
    
    /**
     * Crée un contexte SSL qui accepte tous les certificats (TEST UNIQUEMENT!)
     * En production, utiliser un truststore approprié
     */
    private static SSLContext createTrustAllSSLContext() throws Exception {
        SSLContext ctx = SSLContext.getInstance("TLSv1.3");
        ctx.init(null, new TrustManager[]{
            new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; }
                public void checkClientTrusted(java.security.cert.X509Certificate[] c, String a) {}
                public void checkServerTrusted(java.security.cert.X509Certificate[] c, String a) {}
            }
        }, new java.security.SecureRandom());
        return ctx;
    }
}