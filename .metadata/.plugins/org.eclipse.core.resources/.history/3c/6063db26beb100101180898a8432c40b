package Socket;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.net.ssl.*;
import java.io.*;
import java.net.*;
import java.security.KeyStore;
import java.time.LocalDateTime;
import java.util.Base64;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Serveur TCP Ultra-SÃ©curisÃ©
 * 
 * Protections contre :
 * - Man-in-the-Middle (MITM) : TLS 1.3
 * - Replay Attack : Nonce + Timestamp + Cache
 * - AltÃ©ration : HMAC-SHA256
 * - DoS : Thread Pool + Limites de connexions + Timeouts
 * - Slow clients : Read timeout + Max line length
 * 
 * @author Mohamed Ghoul
 * @version 1.0
 */
public class SecureServer {
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFIGURATION SÃ‰CURITÃ‰
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private static final String SECRET_KEY = "VotreCleSuperSecrete2025!";
    private static final int PORT = 6443;
    private static final int READ_TIMEOUT_MS = 8000;
    private static final int MAX_LINE_LENGTH = 4096;
    private static final long REPLAY_WINDOW_MS = 15000; // 15 secondes
    private static final int MAX_CONNECTIONS = 64;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GESTION DES CONNEXIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private static final ExecutorService threadPool = new ThreadPoolExecutor(
        8, 32, 60, TimeUnit.SECONDS, 
        new LinkedBlockingQueue<>(128),
        new ThreadPoolExecutor.CallerRunsPolicy()
    );
    private static final AtomicInteger activeConnections = new AtomicInteger(0);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CACHE ANTI-REPLAY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private static final ConcurrentMap<String, Long> nonceCache = new ConcurrentHashMap<>();
    
    /**
     * Point d'entrÃ©e du serveur
     */
    public static void main(String[] args) {
        printBanner();
        
        try {
            // DÃ©marrer le serveur TLS
            SSLServerSocket serverSocket = createTLSServerSocket(PORT);
            log("âœ… Serveur dÃ©marrÃ© avec succÃ¨s sur le port " + PORT);
            
            // Nettoyer le cache pÃ©riodiquement
            startCacheCleanupTask();
            
            // Accepter les connexions
            log("ğŸ‘‚ En Ã©coute des connexions...\n");
            
            while (true) {
                try {
                    SSLSocket clientSocket = (SSLSocket) serverSocket.accept();
                    
                    // VÃ©rifier la limite de connexions
                    if (activeConnections.get() >= MAX_CONNECTIONS) {
                        log("âš ï¸  REFUSÃ‰ - Limite de connexions atteinte (" + activeConnections.get() + "/" + MAX_CONNECTIONS + ")");
                        clientSocket.close();
                        continue;
                    }
                    
                    activeConnections.incrementAndGet();
                    threadPool.submit(() -> handleClient(clientSocket));
                    
                } catch (IOException e) {
                    log("âŒ Erreur acceptation: " + e.getMessage());
                }
            }
        } catch (Exception e) {
            System.err.println("\nâŒ [FATAL] Impossible de dÃ©marrer le serveur");
            System.err.println("   Raison: " + e.getMessage());
            System.err.println("\nğŸ“‹ VÃ©rifications :");
            System.err.println("   1. Le fichier serverkeystore.jks existe-t-il ?");
            System.err.println("   2. Le port " + PORT + " est-il disponible ?");
            System.err.println("   3. ExÃ©cutez : lsof -i :" + PORT + " (Linux/Mac) ou netstat -ano | findstr " + PORT + " (Windows)");
            e.printStackTrace();
        }
    }
    
    /**
     * CrÃ©e un ServerSocket TLS sÃ©curisÃ©
     */
    private static SSLServerSocket createTLSServerSocket(int port) throws Exception {
        // Charger le keystore
        char[] keystorePassword = "changeit".toCharArray();
        KeyStore keystore = KeyStore.getInstance("JKS");
        
        try (FileInputStream fis = new FileInputStream("serverkeystore.jks")) {
            keystore.load(fis, keystorePassword);
        }
        
        // Initialiser le KeyManager
        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
        kmf.init(keystore, keystorePassword);
        
        // CrÃ©er le contexte SSL avec TLS 1.3
        SSLContext sslContext = SSLContext.getInstance("TLSv1.3");
        sslContext.init(kmf.getKeyManagers(), null, null);
        
        // CrÃ©er le ServerSocket TLS
        SSLServerSocketFactory factory = sslContext.getServerSocketFactory();
        SSLServerSocket serverSocket = (SSLServerSocket) factory.createServerSocket(port);
        
        // Forcer TLS 1.3 uniquement
        serverSocket.setEnabledProtocols(new String[]{"TLSv1.3"});
        
        return serverSocket;
    }
    
    /**
     * Traite une connexion client
     */
    private static void handleClient(SSLSocket clientSocket) {
        String clientInfo = clientSocket.getRemoteSocketAddress().toString();
        
        try {
            clientSocket.setSoTimeout(READ_TIMEOUT_MS);
            
            BufferedReader in = new BufferedReader(
                new InputStreamReader(clientSocket.getInputStream(), "UTF-8")
            );
            BufferedWriter out = new BufferedWriter(
                new OutputStreamWriter(clientSocket.getOutputStream(), "UTF-8")
            );
            
            log("ğŸ”— CONNECTÃ‰: " + clientInfo + " (Actifs: " + activeConnections.get() + ")");
            
            // Lire et traiter les messages
            String line;
            while ((line = readBoundedLine(in)) != null) {
                String response = processSecureMessage(line, clientInfo);
                out.write(response + "\r\n");
                out.flush();
            }
            
        } catch (SocketTimeoutException e) {
            log("â±ï¸  TIMEOUT: " + clientInfo);
        } catch (IOException e) {
            log("âš ï¸  ERREUR I/O: " + clientInfo + " - " + e.getMessage());
        } finally {
            try {
                clientSocket.close();
            } catch (IOException ignored) {}
            activeConnections.decrementAndGet();
            log("ğŸ”Œ DÃ‰CONNECTÃ‰: " + clientInfo + " (Actifs: " + activeConnections.get() + ")");
        }
    }
    
    /**
     * Traite un message sÃ©curisÃ© avec vÃ©rifications anti-attaque
     * Format attendu: NONCE|TIMESTAMP|MESSAGE|HMAC
     */
    private static String processSecureMessage(String line, String clientInfo) {
        try {
            // Parser le message
            String[] parts = line.split("\\|", 4);
            if (parts.length != 4) {
                log("âŒ FORMAT INVALIDE: " + clientInfo);
                return "ERR:FORMAT_INVALIDE";
            }
            
            String nonce = parts[0];
            String timestampStr = parts[1];
            String message = parts[2];
            String receivedHmac = parts[3];
            
            // VÃ©rifier le timestamp (anti-replay temporel)
            long timestamp;
            try {
                timestamp = Long.parseLong(timestampStr);
            } catch (NumberFormatException e) {
                log("âŒ TIMESTAMP INVALIDE: " + clientInfo);
                return "ERR:TIMESTAMP_INVALIDE";
            }
            
            long now = System.currentTimeMillis();
            long timeDiff = Math.abs(now - timestamp);
            
            if (timeDiff > REPLAY_WINDOW_MS) {
                log("ğŸ”„ REPLAY DÃ‰TECTÃ‰ (temps): " + clientInfo + " - Diff: " + timeDiff + "ms");
                return "ERR:MESSAGE_EXPIRE";
            }
            
            // VÃ©rifier le nonce (anti-replay par unicitÃ©)
            if (nonceCache.putIfAbsent(nonce, now) != null) {
                log("ğŸ”„ REPLAY DÃ‰TECTÃ‰ (nonce): " + clientInfo + " - Nonce: " + nonce.substring(0, 8) + "...");
                return "ERR:REPLAY_ATTACK";
            }
            
            // VÃ©rifier l'intÃ©gritÃ© avec HMAC
            String data = nonce + "|" + timestamp + "|" + message;
            String expectedHmac = calculateHMAC(data, SECRET_KEY);
            
            if (!expectedHmac.equals(receivedHmac)) {
                log("ğŸ” HMAC INVALIDE: " + clientInfo + " - AltÃ©ration dÃ©tectÃ©e!");
                return "ERR:INTEGRITE_COMPROMISE";
            }
            
            // Message valide - Traiter
            log("âœ… MESSAGE VALIDE: " + clientInfo + " - " + preview(message));
            return "OK:MESSAGE_ACCEPTE:" + message;
            
        } catch (Exception e) {
            log("âŒ ERREUR TRAITEMENT: " + clientInfo + " - " + e.getMessage());
            return "ERR:ERREUR_SERVEUR";
        }
    }
    
    /**
     * Calcule le HMAC-SHA256 d'un message
     */
    private static String calculateHMAC(String data, String secret) throws Exception {
        Mac mac = Mac.getInstance("HmacSHA256");
        SecretKeySpec keySpec = new SecretKeySpec(secret.getBytes("UTF-8"), "HmacSHA256");
        mac.init(keySpec);
        byte[] hmacBytes = mac.doFinal(data.getBytes("UTF-8"));
        return Base64.getEncoder().encodeToString(hmacBytes);
    }
    
    /**
     * Lit une ligne avec limitation de taille (anti-DoS)
     */
    private static String readBoundedLine(BufferedReader in) throws IOException {
        StringBuilder sb = new StringBuilder();
        int ch;
        
        while ((ch = in.read()) != -1) {
            if (ch == '\n') {
                break;
            }
            if (ch != '\r') {
                sb.append((char) ch);
            }
            if (sb.length() > MAX_LINE_LENGTH) {
                throw new IOException("Ligne trop longue (> " + MAX_LINE_LENGTH + ")");
            }
        }
        
        return (sb.length() == 0 && ch == -1) ? null : sb.toString();
    }
    
    /**
     * Nettoie pÃ©riodiquement le cache des nonces expirÃ©s
     */
    private static void startCacheCleanupTask() {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        scheduler.scheduleAtFixedRate(() -> {
            long now = System.currentTimeMillis();
            int removed = 0;
            
            for (var entry : nonceCache.entrySet()) {
                if (now - entry.getValue() > REPLAY_WINDOW_MS) {
                    nonceCache.remove(entry.getKey());
                    removed++;
                }
            }
            
            if (removed > 0) {
                log("ğŸ§¹ Cache nettoyÃ©: " + removed + " entrÃ©es supprimÃ©es");
            }
        }, 10, 10, TimeUnit.SECONDS);
    }
    
    /**
     * PrÃ©visualisation d'un message (tronquÃ© si trop long)
     */
    private static String preview(String s) {
        return s.length() > 60 ? s.substring(0, 60) + "..." : s;
    }
    
    /**
     * Journalisation avec timestamp
     */
    private static void log(String message) {
        System.out.println("[" + LocalDateTime.now().toString().substring(11, 19) + "] " + message);
    }
    
    /**
     * Affiche la banniÃ¨re de dÃ©marrage
     */
    private static void printBanner() {
        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘                                                        â•‘");
        System.out.println("â•‘          SERVEUR TCP ULTRA-SÃ‰CURISÃ‰                    â•‘");
        System.out.println("â•‘          Version 1.0 - Mohamed Ghoul                   â•‘");
        System.out.println("â•‘                                                        â•‘");
        System.out.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        System.out.println("â•‘  ğŸ” TLS 1.3         : Chiffrement end-to-end           â•‘");
        System.out.println("â•‘  ğŸ”„ Anti-Replay     : Nonce + Timestamp + Cache        â•‘");
        System.out.println("â•‘  ğŸ›¡ï¸  HMAC-SHA256     : VÃ©rification d'intÃ©gritÃ©        â•‘");
        System.out.println("â•‘  âš¡ Thread Pool     : Gestion optimisÃ©e                â•‘");
        System.out.println("â•‘  ğŸš« Rate Limiting   : Max " + MAX_CONNECTIONS + " connexions simultanÃ©es      â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println();
    }
}